
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [相向双指针](#相向双指针)
  - [例题](#例题)
    - [167.两数之和|| - 输入有序数组](#167两数之和---输入有序数组)
    - [三数之和](#三数之和)
  - [练习](#练习)
    - [2824.统计和小于目标的下标对数量](#2824统计和小于目标的下标对数量)
    - [16.最接近的三数之和](#16最接近的三数之和)
    - [18.四数之和](#18四数之和)
    - [611.有效三角形的个数](#611有效三角形的个数)
  - [总结](#总结)
  - [例题](#例题-1)
    - [11.盛最多水的容器](#11盛最多水的容器)
    - [42.接雨水](#42接雨水)
  - [练习](#练习-1)
    - [125.验证回文串](#125验证回文串)
    - [2105.给植物浇水](#2105给植物浇水)
- [滑动窗口](#滑动窗口)
  - [例题](#例题-2)
    - [209.长度最小的子数组](#209长度最小的子数组)
    - [713.乘积小于K的子数组](#713乘积小于k的子数组)
    - [3.无重复字符的最长子串](#3无重复字符的最长子串)
  - [练习](#练习-2)
    - [3090.每个字符最多出现两次的最长子字符串](#3090每个字符最多出现两次的最长子字符串)
    - [2958.最多k个重复元素的最长子数组](#2958最多k个重复元素的最长子数组)
    - [2730.找到最长的半重复子字符串](#2730找到最长的半重复子字符串)
    - [1004.最大连续1的个数](#1004最大连续1的个数)
    - [2962.统计最大元素出现至少k次的子数组](#2962统计最大元素出现至少k次的子数组)
    - [2302.统计得分小于k的子数组数目](#2302统计得分小于k的子数组数目)
    - [1658.将x减到0的最小操作数](#1658将x减到0的最小操作数)
    - [76.最小覆盖子串](#76最小覆盖子串)
  - [总结](#总结-1)
- [二分查找](#二分查找)
  - [例题](#例题-3)
    - [34.在排序数组中查找元素的第一个和最后一个位置](#34在排序数组中查找元素的第一个和最后一个位置)
    - [162.寻找峰值](#162寻找峰值)
    - [153.寻找旋转排序数组中的最小值](#153寻找旋转排序数组中的最小值)
    - [33.搜索旋转排序数组](#33搜索旋转排序数组)
  - [练习](#练习-3)
    - [2529.正整数和负整数的最大计数](#2529正整数和负整数的最大计数)
    - [2300.咒语和药水的成功对数](#2300咒语和药水的成功对数)
    - [1385.两个数组间的距离值](#1385两个数组间的距离值)
    - [2080.区间内查询数字的频率](#2080区间内查询数字的频率)
    - [2563.统计公平数对的数目](#2563统计公平数对的数目)
    - [875.爱吃香蕉的珂珂](#875爱吃香蕉的珂珂)
    - [2187.完成旅途的最少时间](#2187完成旅途的最少时间)
    - [275.H指数 ||](#275h指数-)
    - [2861.最大合金数](#2861最大合金数)
    - [2439.最小化数组中的最大值](#2439最小化数组中的最大值)
    - [2517.礼盒的最大甜蜜度](#2517礼盒的最大甜蜜度)
    - [74.搜索二维矩阵](#74搜索二维矩阵)
    - [1901.寻找峰值 ||](#1901寻找峰值-)
    - [154.寻找旋转排序数组的最小值||](#154寻找旋转排序数组的最小值)
  - [总结](#总结-2)

<!-- /code_chunk_output -->

# 相向双指针
## 例题
### 167.两数之和|| - 输入有序数组
给你一个下标从 1 开始的整数数组 numbers ，该数组已按**非递减顺序排列**，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
你所设计的解决方案必须只使用常量级的额外空间。

**思路**
**解法1：** 暴力破解遍历每一个元素，再遍历剩下的元素，计算和为target返回结果，时间复杂度：O(n^2)
**解法2：** 相向双指针，定义两个指针指向头和尾，如果和大于target，
代表尾部指向的元素和前面任意的元素相加都大于target，
则不需要考虑这个元素，移动尾部指针向前，小于则移动头部指针向后
（再O(1)的时间干了O(n)的事情）（前提是目标数组有序）
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int left = 0;
        int right = numbers.size() - 1;
        int sum = 0;
        vector<int> result;

        while(left < right)
        {
            sum = numbers[left] + numbers[right];
            if(sum > target)
            {
                right--;
            }
            else if(sum < target)
            {
                left++;
            }
            else
            {
                break;
            }
        }

        result.push_back(left + 1);
        result.push_back(right + 1);

        return result;
    }
};
```

### 三数之和
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。

**思路：**
为方便双指针以及跳过相同元素，先把 nums 排序。枚举 nums[i]，
问题变成 nums[j]+nums[k]=−nums[i]，
这和 167. 两数之和 II - 输入有序数组 是一样的。

题目要求答案中不能有重复的三元组。如何避免重复？

在外层循环中，如果发现 nums[i]=nums[i−1]，那么 nums[i] 与后面两个
数组成的和为 0 的三元组，nums[i−1] 也能组成一模一样的三元组，这就重
复了，所以遇到 nums[i]=nums[i−1] 的情况，直接 continue。

在内层循环中，当三数之和等于 0 时，为避免把相同的三元组计入答案，跳
过后续相同的 nums[j] 和 nums[k]（也可以只跳过相同的 nums[j]）。

**优化：**
**优化一**：如果 nums[i] 与后面最小的两个数相加 nums[i]+nums[i+1]+nums
[i+2]>0，那么后面不可能存在三数之和等于 0，break 外层循环。

**优化二：** 如果 nums[i] 与后面最大的两个数相加 nums[i]+nums[n−2]+nums
[n−1]<0，那么内层循环不可能存在三数之和等于 0，但继续枚举，nums[i]
 可以变大，所以后面还有机会找到三数之和等于 0，continue 外层循环。

**注意：答案中不可以包含重复的三元组。**
```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();

        for(int i = 0; i < n - 2; i++)
        {
            int x = nums[i];
            if(i && x == nums[i - 1]) continue;            //跳过重复元素
            if(x + nums[i + 1] + nums[i + 2] > 0)break;    //优化1
            if(x + nums[n - 2] + nums[n - 1] < 0)continue; //优化2
            
            int j = i + 1;
            int k = n - 1;  
            while(j < k)
            {
                int sum = x + nums[j] + nums[k];
                if(sum > 0)
                {
                    k--;
                }
                else if(sum < 0)
                {
                    j++;
                }
                else
                {
                    ans.push_back({x, nums[j], nums[k]});
                    for(j++; j < k && nums[j] == nums[j - 1]; j++); //跳过重复元素
                    for(k--; j < k && nums[k] == nums[k + 1]; k--); //跳过重复元素

                }
            }
        }

        return ans;
    }
};
```

## 练习
### 2824.统计和小于目标的下标对数量
给你一个下标从 0 开始长度为 n 的整数数组 nums 和一个整数 target ，请你返回满足 0 <= i < j < n 且 nums[i] + nums[j] < target 的下标对 (i, j) 的数目。

**思路：**
从数组中选两个数，我们只关心这两个数的和是否小于 target。
由于 a+b=b+a，无论如何排列数组元素，都不会影响加法的结果。
比如 nums=[1,2], target=4 和 nums=[2,1], target=4 算出来的答案都
是 1，可见排序不影响答案
排序后使用相向双指针解决问题（类似167）
```C++
class Solution {
public:
    int countPairs(vector<int>& nums, int target) {
        ranges::sort(nums);
        int count = 0;
        int left = 0;
        int right = nums.size() - 1;

        while(left < right)
        {
           
            if(nums[left] + nums[right] < target)
            {
                count += right - left;
                left++;
            }
            else
            {
                right--;
            }

        }

        return count;
    }
};
```

### 16.最接近的三数之和
给你一个长度为 n 的整数数组 nums 和 一个目标值 target。请你从 nums 中选出三个整数，**使它们的和与 target 最接近**
返回这三个数的和。
假定每组输入只存在恰好一个解。

**思路：**
思路和 15. 三数之和 类似，排序后，枚举 nums[i] 作为第一个数，那么问题变成找到另外两个数，使得这三个数的和与 target 最接近，这同样可以用双指针解决。

设 s=nums[i]+nums[left]+nums[right]，为了判断 s 是不是与 target 最近的数，我们还需要用一个变量 minDiff 维护 ∣s−target∣ 的最小值。分类讨论：

如果 s=target，那么答案就是 s，直接返回 s。
如果 s>target，那么如果 s−target< minDiff，说明找到了一个与 target 更近的数，更新 minDiff 为 s−target，更新答案为 s。然后和三数之和一样，把 right 减一。
否则 s< target，那么如果 target−s< minDiff，说明找到了一个与 target 更近的数，更新 minDiff 为 target−s，更新答案为 s。然后和三数之和一样，把 left 加一。

**优化**
**优化1** s=nums[i]+nums[i+1]+nums[i+2]。如果 s>target，由于数组已经排序，后面无论怎么选，选出的三个数的和不会比 s 还小，所以不会找到比 s 更优的答案了。所以只要 s>target，就可以直接 break 外层循环了。在 break 前判断 s 是否离 target 更近，如果更近，那么更新答案为 s。

**优化二** s=nums[i]+nums[n−2]+nums[n−1]。如果 s < target，由于数组已经排序，nums[i] 加上后面任意两个数都不超过 s，所以下面的双指针就不需要跑了，无法找到比 s 更优的答案。但是后面还有更大的 nums[i]，可能找到一个离 target 更近的三数之和，所以还需要继续枚举，continue 外层循环。在 continue 前判断 s 是否离 target 更近，如果更近，那么更新答案为 s，更新 minDiff 为 target−s。

**优化3**如果 i>0 且 nums[i]=nums[i−1]，那么 nums[i] 和后面数字相加的结果，必然在之前算出过，所以无需跑下面的双指针，直接 continue 外层循环。（可以放在循环开头判断。）
```C++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        ranges::sort(nums);
        int ans;
        int n = nums.size();
        int minDiff = INT_MAX;

        for(int i = 0; i < n - 2; i++)
        {
            //优化3
            if(i > 0 && x == nums[i - 1])
            {
                continue;
            }

            int x = nums[i];
            // 优化一
            int sum = x + nums[i + 1] + nums[i + 2];
            if (sum > target) // 后面无论怎么选，选出的三个数的和不会比 s 还小
            { 
                if (sum - target < minDiff) 
                {
                    ans = sum; // 由于下面直接 break，这里无需更新 min_diff
                }
                break;
            }

            //优化2
            sum = x + nums[n - 1] + nums[n - 2];
            if(sum < target)//x加上后面任意两个数都不会大于sum，所以不需要循环双指针
            {
                if(target - sum < minDiff)
                {
                    minDiff = target - sum;
                    ans = sum;
                }
                continue;
            }

            int left = i  + 1;
            int right = n - 1;
            while(left < right)
            {
                sum = x + nums[left] + nums[right];
                if(sum > target)
                {
                    if(sum - target < minDiff)
                    {
                        minDiff = sum - target;
                        ans = sum;
                    }
                    right--;
                }
                else if(sum < target)
                {
                    if(target - sum < minDiff)
                    {
                        minDiff = target - sum;
                        ans = sum;
                    }
                    left++;
                }
                else
                {
                    return target;
                }
            }
        }

        return ans;
    }
};
```

### 18.四数之和
给你一个由 n 个整数组成的数组 nums ，和一个目标值 target 。请你找出并返回满足下述全部条件且不重复的四元组 [nums[a], nums[b], nums[c], nums[d]] （若两个四元组元素一一对应，则认为两个四元组重复）：

**思路：**
思路和 15. 三数之和 一样，排序后，枚举 nums[a] 作为第一个数，枚举 nums[b] 作为第二个数，那么问题变成找到另外两个数，使得这四个数的和等于 target，这可以用双指针解决。
```C++
class Solution {
public:
    vector<vector<int>> fourSum(vector<int>& nums, int target) {
        ranges::sort(nums);
        vector<vector<int>> ans;
        int n = nums.size();

        for(int i = 0; i < n - 3; i++)
        {
            long long x = nums[i];
            if(i > 0 && x == nums[i - 1])continue;
            if(x + nums[i + 1] + nums[i + 2] + nums[i + 3] > target)break;
            if(x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target)continue;
            for(int j = i + 1; j < n - 2; j++)
            {
                long long y = nums[j];
                if(j > i + 1 && y == nums[j - 1])continue;
                if(x + y + nums[j + 1] + nums[j + 2] > target)break;
                if(x + y + nums[n - 2] + nums[n - 1] < target)continue;
                int left = j + 1;
                int right = n - 1;
                while(left < right)
                {
                    long long z = x + y + nums[left] + nums[right];
                    if(z > target)right--;
                    else if(z < target)left++;
                    else 
                    {
                        ans.push_back({(int)x, (int)y, nums[left], nums[right]});
                        for(left++; left < right && nums[left] == nums[left - 1]; left++);
                        for(right--; left < right && nums[right] == nums[right + 1]; right--);
                    }
                } 
            }
        }

        return ans;
    }
};
```

### 611.有效三角形的个数
给定一个包含非负整数的数组 nums ，返回其中可以组成三角形三条边的三元组个数。
**思路：**
a + c > b 和 b + c > a一定成立，只需要比较 a + b > c,所以最外层从最长边开始枚举
内层循环使用双指针控制两个较短边

**优化：**
**优化1：** 在执行双指针之前，如果发现最小的 a 和 b 相加大于 c，也就是nums[0]+nums[1]>nums[i]
说明从 nums[0] 到 nums[i] 中任选三个数 a,b,c 都满足 a+b>c，那么直接把剩余数的排列加到结果中
**优化2：** 在执行双指针之前，如果发现最大的 a 和 b 相加小于等于 c，也就是nums[i−2]+nums[i−1]≤nums[i]，说明不存在 a+b>c，不执行双指针，继续外层循环。
```C++
class Solution {
public:
    int triangleNumber(vector<int>& nums) {
        ranges::sort(nums);
        int count = 0;
        int n = nums.size();

        for(int i = n - 1; i > 1; i--)
        {
            //优化1
            if(nums[0] + nums[1] > nums[i])
            {
                count += (i + 1) * (i) * (i - 1) / 6; 
                break;
            }

            //优化2
            if(nums[i - 2] + nums[i - 1] <= nums[i])
            {
                continue;
            }

            int left = 0;
            int right = i - 1;
            while(left < right)
            {
                int sum = nums[left] + nums[right];
                if(sum <= nums[i])
                {
                    left++;
                }
                else
                {
                    count += right - left;
                    right--;
                }
            }
        }

        return count;
    }
};
```

## 总结
**题型的共同性**
1. 需要排序
2. 需要计算两数及以上的和（两数以上的可以先枚举多的数，缩减成两个数的问题）
3. 使用相向双指针一次遍历使用O(1)的时间可以完成O(n)的事情，双指针是对暴力搜索的优化，将一层的循环变为指针的移动

## 例题
### 11.盛最多水的容器
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。

找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

说明：你不能倾斜容器。
**思路：**
定义左右两个指针， 如果想要找到更大的容量，移动长度短的指针
```C++
class Solution {
public:
    int maxArea(vector<int>& height) {
        int n = height.size();
        int left = 0;
        int right = n - 1;
        int ans = 0;
        int tempAns = 0;

        while(left < right)
        {
            tempAns = (right - left) * min(height[left], height[right]);
            ans = max(tempAns, ans);

            height[left] < height[right] ? left++ : right--;
        }

        return ans;
    }
};
```
### 42.接雨水
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。
**思路：**
**解法1：**
前后缀分解，借助两个数组，分别代表前缀最大值（左边的最大高度）的后缀最大值，定义两个指针分别遍历两个数组，前后缀的最小值减去当前的高度得到当前位置的可以接的雨水
```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        vector<int> preMax;
        vector<int> sufMax;
        int ans = 0;

        preMax.resize(n);
        sufMax.resize(n);

        for(int i = 0; i < n; i++)
        {
            if(i == 0) preMax[i] = height[i];
            else preMax[i] = max(preMax[i - 1], height[i]); 
        }

        for(int i = n - 1; i >= 0; i--)
        {
            if(i == n - 1) sufMax[i] = height[i];
            else sufMax[i] = max(sufMax[i + 1], height[i]); 
        }

        for(int i = 0; i < n; i++)
        {
            ans += min(preMax[i], sufMax[i]) - height[i];
        }

        return ans;
    }
};
```
**解法2：** 
相向双指针，不使用数组存储前后缀最大值（减少空间复杂度），定义左右两指针遍历数组，更新前后缀最大值，每次更新计算相对小的前后缀的指针位置的雨水容量，并更新指针
```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int n = height.size();
        int ans = 0;
        int left =  0;
        int right = n - 1;
        int preMax = 0;
        int sufMax = 0;

        while(left < right) 
        {
            preMax = max(preMax, height[left]);
            sufMax = max(sufMax, height[right]);
            ans += preMax < sufMax ? preMax - height[left++] : sufMax - height[right--];
        }

        return ans;
    }
};
```

## 练习
### 125.验证回文串
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。

字母和数字都属于字母数字字符。

给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。
**思路：**
定义左右两个指针，遇到非字母数字的跳过，左右两边找到第一个字母数字，进行相减，差值为32或0表示相同
```C++
class Solution {
public:
    bool isPalindrome(string s) {
        int n = s.size();
        int left = 0;
        int right = n - 1;

        while(left < right)
        {
            if(!isalnum(s[left]))
            {
                left++;
            } 
            else if(!isalnum(s[right]))
            {
                right--;
            }
            else if(tolower(s[left]) == tolower(s[right]))
            {
                left++;
                right--;
            }
            else
            {
                return false;
            }
        }

        return true;
    }
};
```
### 2105.给植物浇水
Alice 和 Bob 打算给花园里的 n 株植物浇水。植物排成一行，从左到右进行标记，编号从 0 到 n - 1 。其中，第 i 株植物的位置是 x = i 。

每一株植物都需要浇特定量的水。Alice 和 Bob 每人有一个水罐，最初是满的 。他们按下面描述的方式完成浇水：

 Alice 按 从左到右 的顺序给植物浇水，从植物 0 开始。Bob 按 从右到左 的顺序给植物浇水，从植物 n - 1 开始。他们 同时 给植物浇水。
无论需要多少水，为每株植物浇水所需的时间都是相同的。
如果 Alice/Bob 水罐中的水足以 完全 灌溉植物，他们 必须 给植物浇水。否则，他们 首先（立即）重新装满罐子，然后给植物浇水。
如果 Alice 和 Bob 到达同一株植物，那么当前水罐中水 更多 的人会给这株植物浇水。如果他俩水量相同，那么 Alice 会给这株植物浇水。
给你一个下标从 0 开始的整数数组 plants ，数组由 n 个整数组成。其中，plants[i] 为第 i 株植物需要的水量。另有两个整数 capacityA 和 capacityB 分别表示 Alice 和 Bob 水罐的容量。返回两人浇灌所有植物过程中重新灌满水罐的 次数 。
**思路：**
相向双指针

```C++
class Solution {
public:
    int minimumRefill(vector<int>& plants, int capacityA, int capacityB) {
        int n = plants.size();
        int Alice = 0;
        int Bob = n - 1;
        int startCapA = capacityA;
        int startCapB = capacityB;
        int ans = 0;

        while(Alice < Bob)
        {
            if(capacityA < plants[Alice])
            {
                ans++;
                capacityA = startCapA;
            }
            capacityA -= plants[Alice];
            Alice++;

            if(capacityB < plants[Bob])
            {
                ans++;
                capacityB = startCapB;
            }
            capacityB -= plants[Bob];
            Bob--;
        }
        if(Alice == Bob && max(capacityA, capacityB) < plants[Alice]) ans++;

        return ans;
    }
};
```
# 滑动窗口
**窗口长度固定的为滑动窗口，不固定的为双指针**
## 例题

### 209.长度最小的子数组
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其总和大于等于 target 的长度最小的 子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

**思路：**
定义同向双指针，right从开始遍历，遍历一个计算当前的和，如果大于等于target记录长度，加入while循环去除多余的left值（sum - left大于target时）
```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int n = nums.size();
        int ans = n + 1;
        int sum = 0;
        int left = 0;
        for(int right = 0; right < n; right++)
        {
            sum += nums[right];
            while(sum - nums[left] >= target)
            {
                sum -= nums[left];
                left++;
            }

            if(sum >= target)
            {
                ans = min(ans, right - left + 1);
            }
        }
        return ans <= n ? ans : 0;
    }
};
```
### 713.乘积小于K的子数组
给你一个整数数组 nums 和一个整数 k ，请你返回子数组内所有元素的乘积严格小于 k 的连续子数组的数目。

**思路：**
注意数据范围 nums[i]≥1，所以乘积不可能小于 1。因此，当 k≤1 时，没有这样的子数组，直接返回 0。

由于子数组越长，乘积越大，越不能满足题目要求；反之，子数组越短，乘积越小，越能满足题目要求。有这种性质的题目，可以用滑动窗口解决。

枚举子数组右端点 right，如果发现子数组不满足要求，就缩小窗口，也就是增大左端点 left。

内层循环结束后，[left,right] 这个子数组是满足题目要求的。由于子数组越短，越能满足题目要求，所以除了 [left,right]，还有 [left+1,right],[left+2,right],…,[right,right] 都是满足要求的。也就是说，当右端点固定在 right 时，左端点在 left,left+1,left+2,…,right 的所有子数组都是满足要求的，这一共有 right−left+1 个，加到答案中。
```C++
class Solution {
public:
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if(k <= 1)  //数组中的所有元素都大于等于1，不可能算出小于1
        {
            return 0;
        }
        int n = nums.size();
        int ans = 0;
        int product = 1;
        int left = 0;

        for(int right = 0; right < n; right++)
        {
            product *= nums[right];
            while(product >= k) //不满足条件
            {
                product /= nums[left];
                left++;
            }
            ans += right - left + 1;
        }

        return ans; 
    }
};
```
### 3.无重复字符的最长子串
给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。

**思路：**
right遍历每一个字符，并添加到一个哈希表中（哈希表的val值大于2，表示有重复元素）内层循环从不满足条件到满足条件（有重复到无重复），移动left指针并更新哈希表
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int n = s.size();
        int ans = 0;
        int left = 0;
        unordered_map<char, int> count;

        for(int right = 0; right < n; right++)
        {
            char c = s[right];
            count[c]++;
            while(count[c] > 1)
            {
                count[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }

        return ans;
    }
};
```

## 练习

###  3090.每个字符最多出现两次的最长子字符串
给你一个字符串 s ，请找出满足每个字符最多出现两次的最长子字符串，并返回该子字符串的 最大 长度。
**思路：**
和3.题一样的思路
```C++
class Solution {
public:
    int maximumLengthSubstring(string s) {
        int n = s.size();
        int ans = 0;
        int left = 0;
        unordered_map<char, int> count;

        for(int right = 0; right < n; right++)
        {
            char c = s[right];
            count[c]++;
            while(count[c] > 2)
            {
                count[s[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        } 

        return ans;
    }
};
```

### 2958.最多k个重复元素的最长子数组
给你一个整数数组 nums 和一个整数 k 。

一个元素 x 在数组中的 频率 指的是它在数组中的出现次数。

如果一个数组中所有元素的频率都 小于等于 k ，那么我们称这个数组是 好 数组。

请你返回 nums 中 最长好 子数组的长度。

子数组 指的是一个数组中一段连续非空的元素序列。
**思路：**
和3.一样

```C++
class Solution {
public:
    int maxSubarrayLength(vector<int>& nums, int k) {
        int n = nums.size();
        int ans = 0;
        int left = 0;
        unordered_map<int, int> cnt;

        for(int right = 0; right < n; right++)
        {
            cnt[nums[right]]++;
            while(cnt[nums[right]] > k)
            {
                cnt[nums[left]]--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }

        return ans;
    }
};
```

### 2730.找到最长的半重复子字符串
给你一个下标从 0 开始的字符串 s ，这个字符串只包含 0 到 9 的数字字符。

如果一个字符串 t 中至多有一对相邻字符是相等的，那么称这个字符串 t 是 半重复的 。例如，"0010" 、"002020" 、"0123" 、"2002" 和 "54944" 是半重复字符串，而 "00101022" （相邻的相同数字对是 00 和 22）和 "1101234883" （相邻的相同数字对是 11 和 88）不是半重复字符串。

请你返回 s 中最长 半重复 子字符串 的长度。
**思路：**
移动右指针 right，并统计相邻相同的情况出现了多少次，记作cnt

如果 cnt>1，则不断移动左指针 left 直到 s[left]=s[left−1]，此时将一对相同的字符移到窗口之外。然后将 cnt 置为 1。

然后统计子串长度 right−left+1 的最大值。
```C++
class Solution {
public:
    int longestSemiRepetitiveSubstring(string s) {
        int n = s.size();
        int ans = 1;
        int left = 0;
        int cnt = 0;

        for(int right = 1; right < n; right++)
        {
            if(s[right] == s[right - 1]) cnt++;

            while(cnt > 1)
            {
                if(s[left] == s[left + 1])
                {
                    cnt--;
                }
                left++;
            }

            ans = max(ans, right - left + 1);
        }

        return ans;
    }
};
```

### 1004.最大连续1的个数
给定一个二进制数组 nums 和一个整数 k，假设最多可以翻转 k 个 0 ，则返回执行操作后 数组中连续 1 的最大个数 
**思路：**
统计窗口内 0 的个数 cnt ，则问题转化成在 cnt ≤k 的前提下，窗口大小的最大值。
```C++
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int n = nums.size();
        int ans = 0;
        int left = 0;
        int cnt = 0;

        for(int right = 0; right < n; right++)
        {
            if(nums[right] == 0) cnt++;
            while(cnt > k)
            {
                if(nums[left] == 0) cnt--;
                left++;
            }
            ans = max(ans, right - left + 1);
        }

        return ans;
    }
};
```
### 2962.统计最大元素出现至少k次的子数组
给你一个整数数组 nums 和一个 正整数 k 。

请你统计有多少满足 「 nums 中的 最大 元素」至少出现 k 次的子数组，并返回满足这一条件的子数组的数目。

子数组是数组中的一个连续元素序列。
**思路：**
每次对left指针找到第一个最大值的位置，right指针不需要下标值，使用foreach循环
```C++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, int k) {
        long long ans = 0;
        int left = 0;
        int max = ranges::max(nums);
        int maxCnt = 0;
         
        for(int i : nums)
        {
            if(i == max) maxCnt++;
            while(maxCnt == k)
            {
                if(nums[left] == max) maxCnt--;
                left++;
            }
            ans += left;
        }
        return ans;
    }
};
```

### 2302.统计得分小于k的子数组数目
一个数组的 分数 定义为数组之和 乘以 数组的长度。

比方说，[1, 2, 3, 4, 5] 的分数为 (1 + 2 + 3 + 4 + 5) * 5 = 75 。
给你一个正整数数组 nums 和一个整数 k ，请你返回 nums 中分数 严格小于 k 的 非空整数子数组数目。

子数组 是数组中的一个连续元素序列。
**思路：**
如果[left right]是合法的，那么这个子数组的内部子数组也是合法的
```C++
class Solution {
public:
    long long countSubarrays(vector<int>& nums, long long k) {
        int n = nums.size();
        long long ans = 0;
        long long sum = 0;
        int left = 0;

        for(int right = 0; right < n; right++)
        {
            sum += nums[right];
            //如果是int sum乘法会先以 int 计算，溢出后再转 long long，结果完全错误
            while(sum * (right - left + 1) >= k)
            {
                sum -= nums[left];
                left++;
            }
            ans += right - left + 1;
        }

        return ans;
    }
};
```

### 1658.将x减到0的最小操作数
给你一个整数数组 nums 和一个整数 x 。每一次操作时，你应当移除数组 nums 最左边或最右边的元素，然后从 x 中减去该元素的值。请注意，需要 修改 数组以供接下来的操作使用。

如果可以将 x 恰好 减到 0 ，返回 最小操作数 ；否则，返回 -1 。
**思路：**
正难则反
移除的是 nums 最左边或最右边的元素，那么剩下的元素是什么？是 nums 的连续子数组。
移除的元素和 x + 剩余的元素和 = nums 的所有元素之和 s。
所以剩余的元素和 = s−x。
问题变成：
从 nums 中找最长的子数组（这样移除的数尽量少），满足子数组的元素和恰好等于 s−x。
```C++
class Solution {
public:
    int minOperations(vector<int>& nums, int x) {
        int n = nums.size();
        int left = 0;
        int ans = -1;
        int sum = 0;

        int target = reduce(nums.begin(), nums.end()) - x;
        if(target < 0)
        {
            return -1;
        }

        for(int right = 0; right < n; right++)
        {
            sum += nums[right];
            while(sum > target)
            {
                sum -= nums[left];
                left++;
            }
            if(sum == target)
            {
                ans = max(ans, right - left + 1);
            }
        }

        return ans < 0 ? -1 : n - ans;
        
    }
};
```

### 76.最小覆盖子串
给定两个字符串 s 和 t，长度分别是 m 和 n，返回 s 中的 最短窗口 子串，使得该子串包含 t 中的每一个字符（包括重复字符）。如果没有这样的子串，返回空字符串 ""。

测试用例保证答案唯一。
**思路：**
原理和 209 题一样，我们枚举 s 子串的右端点 right（子串最后一个字母的下标），如果子串涵盖 t，就不断移动左端点 left 直到不涵盖为止。在移动过程中更新最短子串的左右端点。
```C++
class Solution {
public:
    bool IsCovered(int cntS[], int cntT[])
    {
        for(int i = 'A'; i <= 'Z'; i++)
        {
            if(cntS[i] < cntT[i]) return false;
        } 
        for(int i = 'a'; i <= 'z'; i++)
        {
            if(cntS[i] < cntT[i]) return false;
        } 

        return true;
    }


public:
    string minWindow(string s, string t) {
        int cntS[128]{};  //s子串字母出现的次数
        int cntT[128]{};  //t中字母出现的次数
        for(char c : t)
        {
            cntT[c]++;
        }

        int n = s.size();
        int ansLeft = -1;
        int ansRight = n;
        int left = 0;
        for(int right = 0; right < n; right++)
        {
            cntS[s[right]]++;  
            while(IsCovered(cntS, cntT))
            {
                if(right - left < ansRight - ansLeft)
                {
                    ansLeft = left;
                    ansRight = right;
                }
                cntS[s[left]]--;
                left++;
            }
        }
        return ansLeft < 0 ? "" : s.substr(ansLeft, ansRight - ansLeft + 1);
    }
};
```
## 总结
1. 内层循环移动的指针可以从满足条件到不满足条件（或者相反），最长，最短方案数
2. 连续子数组/子串。
3. 有单调性。

# 二分查找

## 例题 
### 34.在排序数组中查找元素的第一个和最后一个位置

**思路：**
在有顺序的数据中定义left和right两个指针，计算mid = left+(right-left)/2 和target对比，维护两个不变量nums[left-1] < target和nums[right+1] >= target，注意保持区间开闭的一致性

**要想找到 ≤target 的最后一个数**，无需单独再写一个二分。我们可以先找到这个数的右边相邻数字，也就是 >target 的第一个数。在所有数都是整数的前提下，>target 等价于 ≥target+1，这样就可以复用我们已经写好的二分函数了，即 lowerBound(nums, target + 1)，算出这个数的下标后，将其减一，就得到 ≤target 的最后一个数的下标。

**判断区间**看 while 循环的条件，如果是 left <= right，就是闭区间；如果是 left < right，就是半闭半开区间；如果是 left + 1 < right，就是开区间。
```C++
//闭区间
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的下标 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
    int lower_bound(vector<int>& nums, int target) {
        int left = 0, right = (int) nums.size() - 1; // 闭区间 [left, right]
        while (left <= right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right+1] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid - 1; // 范围缩小到 [left, mid-1]
            } else {
                left = mid + 1; // 范围缩小到 [mid+1, right]
            }
        }
        // 循环结束后 left = right+1
        // 此时 nums[left-1] < target 而 nums[left] = nums[right+1] >= target
        // 所以 left 就是第一个 >= target 的元素下标
        return left;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1}; // nums 中没有 target
        }
        // 如果 start 存在，那么 end 必定存在
        int end = lower_bound(nums, target + 1) - 1;
        return {start, end};
    }
};
```

```C++
//左闭右开区间
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的下标 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
    int lower_bound(vector<int>& nums, int target) {
        int left = 0, right = nums.size(); // 左闭右开区间 [left, right)
        while (left < right) { // 区间不为空
            // 循环不变量：
            // nums[left-1] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid; // 范围缩小到 [left, mid)
            } else {
                left = mid + 1; // 范围缩小到 [mid+1, right)
            }
        }
        // 循环结束后 left = right
        // 此时 nums[left-1] < target 而 nums[left] >= nums[right] >= target
        // 所以 left 就是第一个 >= target 的元素下标
        return left;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1}; // nums 中没有 target
        }
        // 如果 start 存在，那么 end 必定存在
        int end = lower_bound(nums, target + 1) - 1;
        return {start, end};
    }
};
```

```C++
//开区间
class Solution {
    // lower_bound 返回最小的满足 nums[i] >= target 的下标 i
    // 如果数组为空，或者所有数都 < target，则返回 nums.size()
    // 要求 nums 是非递减的，即 nums[i] <= nums[i + 1]
    int lower_bound(vector<int>& nums, int target) {
        int left = -1, right = nums.size(); // 开区间 (left, right)
        while (left + 1 < right) { // 区间不为空
            // 循环不变量：
            // nums[left] < target
            // nums[right] >= target
            int mid = left + (right - left) / 2;
            if (nums[mid] >= target) {
                right = mid; // 范围缩小到 (left, mid)
            } else {
                left = mid; // 范围缩小到 (mid, right)
            }
        }
        // 循环结束后 left+1 = right
        // 此时 nums[left] < target 而 nums[right] >= target
        // 所以 right 就是第一个 >= target 的元素下标
        return right;
    }

public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int start = lower_bound(nums, target);
        if (start == nums.size() || nums[start] != target) {
            return {-1, -1}; // nums 中没有 target
        }
        // 如果 start 存在，那么 end 必定存在
        int end = lower_bound(nums, target + 1) - 1;
        return {start, end};
    }
};
```

### 162.寻找峰值
峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。

你可以假设 nums[-1] = nums[n] = -∞ 。

你必须实现时间复杂度为 O(log n) 的算法来解决此问题。
**思路：**
循环不变量：
    > left 的下标中存在峰值下标
    <= right 的下标中存在峰值下标
    任何时刻都满足(left right]中有峰值下标

```C++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[mid + 1])
            {
                right = mid;
            } 
            else
            {
                left = mid;
            }
        }
        return right;
    }
};
```

### 153.寻找旋转排序数组中的最小值
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,2]
若旋转 7 次，则可以得到 [0,1,2,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```C++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums.back())
            {
                left = mid;
            }
            else if(nums[mid] < nums.back())
            {
                right = mid;
            }
        }
        return nums[right];
    }
};
```

### 33.搜索旋转排序数组
整数数组 nums 按升序排列，数组中的值 互不相同 。

在传递给函数之前，nums 在预先未知的某个下标 k（0 <= k < nums.length）上进行了 向左旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 下标 3 上向左旋转后可能变为 [4,5,6,7,0,1,2] 。

给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。

你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。

```C++
//一次二分
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int last = nums.back();
        int left = -1;
        int right = nums.size() - 1;
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            if(target > last && nums[mid] <= last)
            {
                right = mid;
            }
            else if(nums[mid] > last && target <= last)
            {
                left = mid;
            }
            else if(nums[mid] >= target)
            {
                right = mid;
            }
            else
            {
                left = mid;
            }
        }
        return nums[right] == target ? right : -1;
    }
};
```
## 练习

### 2529.正整数和负整数的最大计数
给你一个按 非递减顺序 排列的数组 nums ，返回正整数数目和负整数数目中的最大值。

换句话讲，如果 nums 中正整数的数目是 pos ，而负整数的数目是 neg ，返回 pos 和 neg二者中的最大值。
注意：0 既不是正整数也不是负整数。
**思路:**
根据ranges::lower_bound()和ranges::upper_bound()返回第一个插入不会破坏数组有序结构(下界)的的迭代器,和最后一个不会破坏数组有序结构(上界)的迭代器
```C++
class Solution {
public:
    int maximumCount(vector<int>& nums) {
        int neg = ranges::lower_bound(nums, 0) - nums.begin();
        int pos = nums.end() - ranges::upper_bound(nums, 0);
        return max(neg, pos);
    }
};
```

### 2300.咒语和药水的成功对数
给你两个正整数数组 spells 和 potions ，长度分别为 n 和 m ，其中 spells[i] 表示第 i 个咒语的能量强度，potions[j] 表示第 j 瓶药水的能量强度。

同时给你一个整数 success 。一个咒语和药水的能量强度 相乘 如果 大于等于 success ，那么它们视为一对 成功 的组合。

请你返回一个长度为 n 的整数数组 pairs，其中 pairs[i] 是能跟第 i 个咒语成功组合的 药水 数目。
```C++
class Solution {
public:
    vector<int> successfulPairs(vector<int>& spells, vector<int>& potions, long long success) {
        ranges::sort(potions);
        for(int& x : spells)
        {
           long long target = (success - 1) / x;
           if(target < potions.back())
           {
                x = potions.end() - ranges::upper_bound(potions, (int)target);
           }
           else
           {
                x = 0;
           }
        }

        return spells;
    }
};
```

### 1385.两个数组间的距离值
给你两个整数数组 arr1 ， arr2 和一个整数 d ，请你返回两个数组之间的 距离值 。

「距离值」 定义为符合此距离要求的元素数目：对于元素 arr1[i] ，不存在任何元素 arr2[j] 满足 |arr1[i]-arr2[j]| <= d 。
**思路：**
把 arr 2从小到大排序，这样我们可以二分查找。
遍历 arr 1，设 x=arr1[i]。我们要判断在 arr2中是否存在元素，在闭区间 [x−d,x+d] 中。
考虑 [x−d,x+d] 中的第一个数（最左边的数），也就是在 arr2中二分查找 ≥x−d 的最小的数 y。如果 y 不存在，或者 y>x+d，则说明没有在 [x−d,x+d] 中的元素，符合题目要求，把答案加一。

```C++
class Solution {
public:
    int findTheDistanceValue(vector<int>& arr1, vector<int>& arr2, int d) {
        ranges::sort(arr2);
        int ans = 0;
        for(int x : arr1)
        {
            auto it = ranges::lower_bound(arr2, x - d);
            if(it == arr2.end() || *it > x + d) ans++;
        }
        return ans;
    }
};
```
### 2080.区间内查询数字的频率
请你设计一个数据结构，它能求出给定子数组内一个给定值的 频率 。

子数组中一个值的 频率 指的是这个子数组中这个值的出现次数。

请你实现 RangeFreqQuery 类：

RangeFreqQuery(int[] arr) 用下标从 0 开始的整数数组 arr 构造一个类的实例。
int query(int left, int right, int value) 返回子数组 arr[left...right] 中 value 的 频率 。
一个 子数组 指的是数组中一段连续的元素。arr[left...right] 指的是 nums 中包含下标 left 和 right 在内 的中间一段连续元素。
**思路：**
对于 arr 中的每个数，计算其在 arr 中的出现位置（下标）。例如 arr=[1,2,1,1,2,2]，其中数字 2 的下标为 [1,4,5]。

知道了下标，那么对于 query 来说，问题就变成了：

下标列表中，满足 left≤i≤right 的下标 i 的个数。
例如 query(3,5,2)，由于数字 2 的下标列表 [1,4,5] 中的下标 4 和 5 都在区间 [3,5] 中，所以返回 2。

把下标列表记作数组 a，由于 a 是有序数组，我们可以用二分查找快速求出：

a 中的第一个 ≥left 的数的下标，设其为 p。如果不存在，则 p 等于 a 的长度。
a 中的第一个 >right 的数的下标，设其为 q。如果不存在，则 q 等于 a 的长度。
a 中的下标在 [p,q−1] 内的数都是满足要求的，这有 q−p 个。特别地，如果 a 中没有满足要求的下标，那么 q−p=0，这仍然是正确的。
```C++
class RangeFreqQuery {
    unordered_map<int, vector<int>> pos;

public:
    RangeFreqQuery(vector<int>& arr) {
        for(int i = 0; i < arr.size(); i++)
        {
            pos[arr[i]].push_back(i);
        }
    }
    
    int query(int left, int right, int value) {
        auto it = pos.find(value);
        if(it == pos.end())
        {
            return 0;
        }
        auto& a = it->second;
        return ranges::upper_bound(a, right) - ranges::lower_bound(a, left);

         
    }
};

/**
 * Your RangeFreqQuery object will be instantiated and called as such:
 * RangeFreqQuery* obj = new RangeFreqQuery(arr);
 * int param_1 = obj->query(left,right,value);
 */
```

### 2563.统计公平数对的数目
给你一个下标从 0 开始、长度为 n 的整数数组 nums ，和两个整数 lower 和 upper ，返回 公平数对的数目 。

如果 (i, j) 数对满足以下情况，则认为它是一个 公平数对 ：

0 <= i < j < n，且
lower <= nums[i] + nums[j] <= upper
**思路：**
排序后，枚举右边的 nums[j]，那么左边的 nums[i] 需要满足 0≤i< j 以及

lower−nums[j]≤nums[i]≤upper−nums[j]
计算 ≤upper−nums[j] 的元素个数，减去 < lower−nums[j] 的元素个数，即为满足上式的元素个数。（联想一下前缀和）
处。
```C++
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
        ranges::sort(nums);
        long long ans = 0;
        for(int j = 0; j < nums.size(); j++)
        {
            auto r = upper_bound(nums.begin(), nums.begin() + j, upper - nums[j]);
            auto l = lower_bound(nums.begin(), nums.begin() + j, lower - nums[j]);
            ans += r - l;
        }

        return ans;
    }
};
```

### 875.爱吃香蕉的珂珂
珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 h 小时后回来。

珂珂可以决定她吃香蕉的速度 k （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 k 根。如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）。
**思路：**
看题解
```C++
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        auto check = [&](int k) -> bool
        {
            int sum = piles.size();
            for(int p : piles)
            {
                sum += (p - 1) / k;
                if(sum > h)
                {
                    return false;
                }
            }
            return true;
        };

        int left = 0;
        int right = ranges::max(piles);
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            (check(mid) ? right : left) = mid;
        }
        return right;
    }
};
```

### 2187.完成旅途的最少时间
给你一个数组 time ，其中 time[i] 表示第 i 辆公交车完成 一趟旅途 所需要花费的时间。

每辆公交车可以 连续 完成多趟旅途，也就是说，一辆公交车当前旅途完成后，可以 立马开始 下一趟旅途。每辆公交车 独立 运行，也就是说可以同时有多辆公交车在运行且互不影响。

给你一个整数 totalTrips ，表示所有公交车 总共 需要完成的旅途数目。请你返回完成 至少 totalTrips 趟旅途需要花费的 最少 时间。

**思路：**
时间越多，可以完成的旅途也就越多；时间越少，可以完成的旅途也就越少。有这样的性质，我们可以二分猜答案

```C++
class Solution {
public:
    long long minimumTime(vector<int>& time, int totalTrips) {
        auto check = [&](long long x) -> bool
        {
            long long sum = 0;
            for(int t : time)
            {
                sum += x / t;
                if(sum >= totalTrips)
                {
                    return true;
                }
            }
            return false;
        };

        int minTime = ranges::min(time);
        long long left = minTime - 1;
        long long right = 1LL * minTime * totalTrips;
        while(left + 1 < right)
        {
            long long mid = left + (right - left) / 2;
            (check(mid) ? right : left) = mid; 
        }
        return right;
    }
};
```

### 275.H指数 ||
给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 非降序排列 。计算并返回该研究者的 h 指数。

h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （n 篇论文中）至少 有 h 篇论文分别被引用了至少 h 次。

请你设计并实现对数时间复杂度的算法解决此问题。
**思路：**
left是最后一个引用次数<论文数
right是第一个引用次数>=论文数
如果right依旧等于n，表示没有引用次数>=论文数的返回0；否则返回n-right
```C++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        int left = -1;
        int right = citations.size();
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            if(citations[mid] >= citations.size() - mid)
            {
                right = mid;
            }
            else
            {
                left = mid;
            }
        }
        return right == citations.size() ? 0 : citations.size() - right;

    }
};
```

### 2861.最大合金数
假设你是一家合金制造公司的老板，你的公司使用多种金属来制造合金。现在共有 n 种不同类型的金属可以使用，并且你可以使用 k 台机器来制造合金。每台机器都需要特定数量的每种金属来创建合金。

对于第 i 台机器而言，创建合金需要 composition[i][j] 份 j 类型金属。最初，你拥有 stock[x] 份 x 类型金属，而每购入一份 x 类型金属需要花费 cost[x] 的金钱。

给你整数 n、k、budget，下标从 1 开始的二维数组 composition，两个下标从 1 开始的数组 stock 和 cost，请你在预算不超过 budget 金钱的前提下，最大化 公司制造合金的数量。

所有合金都需要由同一台机器制造。

返回公司可以制造的最大合金数。
**思路：**
题解
```C++
class Solution {
public:
    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {
        int ans = 0;
        int mx = ranges::min(stock) + budget;
        for(auto& comp : composition)
        {
            auto check = [&](long long num) -> bool
            {
                long long money = 0;
                for(int i = 0; i < n; i++)
                {
                    if(stock[i] < comp[i] * num)
                    {
                        money += (comp[i] * num - stock[i]) * cost[i];
                        if(money > budget)
                        {
                            return false;
                        } 
                    }
                }
                return true;
            };

            int left = ans;
            int right = mx + 1;
            while(left + 1 < right)
            {
                int mid = left + (right - left) / 2;
                (check(mid) ? left : right) = mid;
            }
            ans = left;
        }
        return ans;
    }
};
```
### 2439.最小化数组中的最大值
给你一个下标从 0 开始的数组 nums ，它含有 n 个非负整数。

每一步操作中，你需要：

选择一个满足 1 <= i < n 的整数 i ，且 nums[i] > 0 。
将 nums[i] 减 1 。
将 nums[i - 1] 加 1 。
你可以对数组执行 任意 次上述操作，请你返回可以得到的 nums 数组中 最大值 最小 为多少。

```C++
class Solution {
public:
    int minimizeArrayValue(vector<int>& nums) {
        auto check = [&](int limit) -> bool
        {
            long long extra = 0;
            for(int i = nums.size() - 1; i > 0; i--)
            {
                long long newNum = nums[i] + extra;
                extra = max(newNum - limit, 0LL);
            }
            return nums[0] + extra <= limit;
        };

        int left = 0;
        int right = ranges::max(nums);
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            (check(mid) ? right : left) = mid;
        }
        return right;
    }
};
```

### 2517.礼盒的最大甜蜜度
给你一个正整数数组 price ，其中 price[i] 表示第 i 类糖果的价格，另给你一个正整数 k 。

商店组合 k 类 不同 糖果打包成礼盒出售。礼盒的 甜蜜度 是礼盒中任意两种糖果 价格 绝对差的最小值。

返回礼盒的 最大 甜蜜度。

```C++
class Solution {
public:
    int maximumTastiness(vector<int>& price, int k) {
        auto f = [&](int d) -> int {
            int cnt = 1, pre = price[0]; // 先选一个最小的甜蜜度
            for (int p : price) {
                if (p - pre >= d) { // 可以选
                    cnt++;
                    pre = p; // 上一个选的甜蜜度
                }
            }
            return cnt;
        };

        ranges::sort(price);
        int left = 0;
        int right = (price.back() - price[0]) / (k - 1) + 1;
        while (left + 1 < right) { // 开区间不为空
            // 循环不变量：
            // f(left) >= k
            // f(right) < k
            int mid = left + (right - left) / 2;
            (f(mid) >= k ? left : right) = mid;
        }
        return left; // 最大的满足 f(left) >= k 的数
    }
}; 
```

### 74.搜索二维矩阵
给你一个满足下述两条属性的 m x n 整数矩阵：

每行中的整数从左到右按非严格递增顺序排列。
每行的第一个整数大于前一行的最后一个整数。
给你一个整数 target ，如果 target 在矩阵中，返回 true ；否则，返回 false 。
**思路：**
先确定target在哪一行，将target和每一行的最后一个进行对比
在确定的那行进行二分搜索

```C++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        //先确定target在那行中
        int cow = -1;
        for(int i = 0; i < matrix.size(); i++)
        {
            if(matrix[i].back() >= target)
            {
                cow = i;
                break;
            }
        }
        if(cow == -1) return false;

        int left = -1;
        int right = matrix[0].size() - 1;
        while(left + 1 < right)
        {
            int mid = left + (right - left) / 2;
            if(matrix[cow][mid] >= target)
            {
                right = mid;
            }
            else
            {
                left = mid;
            }
        }

        return matrix[cow][right] == target ? true : false;
    }
};
```

### 1901.寻找峰值 ||
一个 2D 网格中的 峰值 是指那些 严格大于 其相邻格子(上、下、左、右)的元素。

给你一个 从 0 开始编号 的 m x n 矩阵 mat ，其中任意两个相邻格子的值都 不相同 。找出 任意一个 峰值 mat[i][j] 并 返回其位置 [i,j] 。

你可以假设整个矩阵周边环绕着一圈值为 -1 的格子。

要求必须写出时间复杂度为 O(m log(n)) 或 O(n log(m)) 的算法

```C++
class Solution {
    int IndexOfMax(vector<int>& a)
    {
        return ranges::max_element(a) - a.begin();
    }
public:
    vector<int> findPeakGrid(vector<vector<int>>& mat) {
        int left = -1;
        int right = mat.size() - 1;
        while(left + 1 < right)
        {
            int i = left + (right - left) / 2;
            int j = IndexOfMax(mat[i]);
            (mat[i][j] > mat[i + 1][j] ? right : left) = i;
        }
        return {right, IndexOfMax(mat[right])};
    }
};
```

### 154.寻找旋转排序数组的最小值||
已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,4,4,5,6,7] 在变化后可能得到：
若旋转 4 次，则可以得到 [4,5,6,7,0,1,4]
若旋转 7 次，则可以得到 [0,1,4,4,5,6,7]
注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。

给你一个可能存在 重复 元素值的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。

你必须尽可能减少整个过程的操作步骤。
```C++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = -1;
        int right = nums.size() - 1;
        while(left + 1 < right) 
        {
            int mid = left + (right - left) / 2;
            if(nums[mid] > nums[right])
            {
                left = mid;
            }
            else if(nums[mid] < nums[right])
            {
                right = mid;
            }
            else
            {
                right--;
            }
        }
        return nums[right];
    }
};
```

## 总结
1. 保持开闭区间的统一性,开闭区间表示当前位置在不在"待查找的范围内"
闭区间:表示边界值在查找的范围内;开区间:表示边界值不在查找的范围内
2. 循环不变量：L-1始终是红色， R+1始终是蓝色
3. 根据upper和lower计算一个范围
4. 多个数进行操作，推导成一个数个范围问题（向上取整转换向下取整）
5. **二分答案** 1.确定答案的范围 2.设计check函数 3.在确定的范围内根据check（）二分循环确定答案
6. 查询的数据不一定有序，left和right能保持各自的性质不变即可，本质上是红和蓝维护一定的性质